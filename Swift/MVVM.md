- 화면 이동을 ViewModel에서 하는 것을 기본적으로 추구한다.
- 실무에서는 ViewModel이 복잡해져서 실무에서는 Coordinator pattern을 사용한다.
	- Coordinator Pattern 화면 이동과 관련된 부분을 관리하는 객체를 따로 만든다.

## 구조
- Model
	- 데이터
	- 데이터 배열
- View
	- 화면
	- MVC에서 View와 ViewController을 합쳤다고 생각하면 된다.
- ViewModel
	- 뷰를 위한 데이터
	- 데이터를 가지는 계층
		- 모델(데이터)을 가짐
		- 로직을 가짐
	- 일반적으로 구조체로 만들지않고 클래스로 만든다.
		- ViewModel이 구조체로 되어있는 데이터를 소유하는 경우가 많고
		- SwiftUI로 넘어가면 뷰모델을 관찰할 수 있는 클래스 객체로 만드는 경우가 많다.


# flow

1. 사용자의 인풋이 View를 통해 들어온다.
2. 인풋을 ViewModel로 전달한다.
3. Model(데이터)를 변화시킨다.
4. 바뀐 결과를 ViewModel로 받아온다.
5. 받아온 결과를 가지고 다시 표시 시킬 수 있도록 전달(뷰를 다시 그릴 수 있도록 전달)

# MVVM 장점
## View
- 비대해지지 않음
- 역할이 줄어듬
- 테스트 코드 작성 가능 ( 뷰/뷰컨트롤러는 최대한 빈 껍데기 역할 )
## ViewModel
- 로직만 가지고 테스트 코드 작성 가능
- 데이터가 변했을 때 반응형으로 전달할 수도 있다. 그것이 [[RXSwift]]
- Model, Output, Input, Logic이 필요하다.

# 왜 아키텍처 패턴이 필요할까?
## 왜 코드를 나누려고 하는가
- 한 곳에 코드를 모두 작성하면 협업하는데 방해가 된다.

# 의존성 주입(Dependency Injection)
- [[Protocol]]을 사용해서 의존성 분리 및 의존관계 역전시킴
- 주입을 하되 [[Protocol]] 타입으로 주입해서 여러가지 코드로 확장할 수 있도록한다.

- 의존성
	- 서로 다른 객체 사이에 의존 관계가 있다는 것
- 주입
	- 외부에서 객체(또는 데이터)를 생성해서 넣는 것(생성자를 통해)
- 의존성 주입
	- 프로그램 디자인이 결합도를 느슨하게 되도록하고 **의존관계 역전 원칙**과 **단일 책임 원칙**을 따르도록 클라이언트 생성에 대한 의존성을 클라이언트의 행위로 부터 분리하는 것
- 기존의 의존성을 개선하여 "(개선된) 의존성을 외부에서 주입할 수 있는 방식"으로 바꾸는 것
- (개선된) 의존성
	- 프로토콜을 사용해서 의존성을 분리시키고 의존관계를 역전(Inversion Of Control)시킴
- 주입
	- 생성자를 통해서 외부에서 값을 주입한다.
	- (생성시 값 할당 가능 / 언제든지 교체 가능해서 확장성이 늘어남)
- 의존성 주입
	- 기존의 의존성을 개선하여 "(개선된) 의존성을 외부에서 주입할 수 있는 방식"으로 바꾸는 것
- 의존성 주입의 장점 / 사용하는 이유
	- 객체 간의 의존성을 줄여서 코드의 재활용성 / 확장성이 높아짐
	- 객체 간의 결합도가 낮아져 유연한 코드/유연한 프로그램을 작성 가능
	- 유지 보수 쉬워짐
	- Unit Test 가능해짐 ( 특정 객체에 대한 의존성 없애고 Test객체 주입가능 )
- 객체지향 프로그래밍(OPP)의 5대 원칙(SOLID) 중
	- 하나가 의존 관계 역전 원칙 (DIP: Dependency Inversion Principle) (의존 관계의 분리)
	- 추상화된 것은 구체적인 것에 의존하면 안되고, 구체적인 것이 추상화된 것에 의존해야 한다.
	- 즉, 구체적인 객체는 추상화된 객체(프로토콜)에 의존해야 한다.
## 주입의 개념
- 생성자를 통해서 저장 속성을 외부에서 주입한다.
```swift
class Person {
    var name: String
    
    init(name: String) {
        self.name = name
    }
}

// 외부에서 값을 주입(할당/초기화)해서 인스턴스 생성
let p1 = Person(name: "뉴진스")
```

 