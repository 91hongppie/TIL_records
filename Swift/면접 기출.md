# 스위프트에서 Extension은 어떻게 사용되나요?
- [[Extension]]은 [[Class]], [[Struct]], [[Enum]] 타입에 새로운 메서드, 프로퍼티, 생성자를 추가적으로 정의해 사용하기위해 사용된다.
- 이 때 저장 프로퍼티는 [[Extension]]에 정의할 수 없고, 연산 프로퍼티(메서드)만 정의할 수 있다.
- 소멸자(deinitializer)는 추가할 수 없고, 생성자는 [[convenience init]]만 정의할 수 있다.
- [[Struct]] 경우에는 기존 구조체에서는 생성자를 직접 구현하면 [[Memberwise initializer]](기본 생성자)가 사라지지만 [[Struct]]의 [[Extension]]에 생성자를 정의하면 [[Memberwise initializer]]가 사라지지 않는다.
- [[where]]을 사용하면 특정한 조건을 가진 타입에 대해서만 [[Extension]]을 적용할 수 있다.
```swift
extension Array where Element: Idable {
	func filterWithId(id: String) -> [Element] {
		return self.filter { (item) -> Bool in
			return item.id == id
		}
	}
}
```

# Swift의 upcasting과 downcasting의 차이에 대해서 설명해보세요
- 서로 상속 관계에 있는 [[Class]]에서 자식 클래스를 부모 클래스로 타입캐스팅 하는 것을 업캐스팅이라고 하고 as를 사용해서 업캐스팅 할 수 있다.
- 컴파일 타임에 업캐스팅이 가능한지 여부가 판별되기 때문에 컴파일이 되면 항상 성공한다.
```swift
class Student {
	let name: String

	init(name: String) {
		self.name = name
	}
}

class HighSchoolStudent: Student {
	let gpa: Double

	init(name: String, gpa: Double) {
		self.gpa = gpa
		super.init(name: name)
	}
}

let hun = HighSchoolStudent(name: "hun", gpa: 4.5)
let upcasted = hun as Student

print(hun.name, hun.gpa)
print(upcated.name, upcasted.gpa) // compile error
```
- 다운캐스팅도 as를 사용하지만 다운 캐스팅은 실패할수도 있기때문에 as?나 as!를 사용한다.
- as!는 런타임에 타입 캐스팅을 하고 만약 타입 캐스팅에 실패하면 런타임 에러를 발생시킨다.
- as?는 런타임에 타입 캐스팅을 하고 만약 타입 캐스팅에 실패하면 nil을 반환한다.
```swift
let downcastedHun = hun as? HighSchoolStudent
print(downcastedHun) // nil

let forcelyDownCastedHun = hun as! HighSchoolStudent // runtime error
print(forcelyDownCastedHun)
```

# \==연산자와 \=\==연산자의 차이
- == 연산자는 값을 비교하는데 사용하고 === 연산자는 참조 값을 비교하는데 사용한다.
