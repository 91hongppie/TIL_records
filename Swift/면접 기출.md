# 1. 스위프트에서 Extension은 어떻게 사용되나요?
- [[Extension]]은 [[Class]], [[Struct]], [[Enum]] 타입에 새로운 메서드, 프로퍼티, 생성자를 추가적으로 정의해 사용하기위해 사용된다.
- 이 때 저장 프로퍼티는 [[Extension]]에 정의할 수 없고, 연산 프로퍼티(메서드)만 정의할 수 있다.
- 소멸자(deinitializer)는 추가할 수 없고, 생성자는 [[convenience init]]만 정의할 수 있다.
- [[Struct]] 경우에는 기존 구조체에서는 생성자를 직접 구현하면 [[Memberwise initializer]](기본 생성자)가 사라지지만 [[Struct]]의 [[Extension]]에 생성자를 정의하면 [[Memberwise initializer]]가 사라지지 않는다.
- [[where]]을 사용하면 특정한 조건을 가진 타입에 대해서만 [[Extension]]을 적용할 수 있다.
```swift
extension Array where Element: Idable {
	func filterWithId(id: String) -> [Element] {
		return self.filter { (item) -> Bool in
			return item.id == id
		}
	}
}
```

# 2. Swift의 upcasting과 downcasting의 차이에 대해서 설명해보세요
- 서로 상속 관계에 있는 [[Class]]에서 자식 클래스를 부모 클래스로 타입캐스팅 하는 것을 업캐스팅이라고 하고 as를 사용해서 업캐스팅 할 수 있다.
- 컴파일 타임에 업캐스팅이 가능한지 여부가 판별되기 때문에 컴파일이 되면 항상 성공한다.
```swift
class Student {
	let name: String

	init(name: String) {
		self.name = name
	}
}

class HighSchoolStudent: Student {
	let gpa: Double

	init(name: String, gpa: Double) {
		self.gpa = gpa
		super.init(name: name)
	}
}

let hun = HighSchoolStudent(name: "hun", gpa: 4.5)
let upcasted = hun as Student

print(hun.name, hun.gpa)
print(upcated.name, upcasted.gpa) // compile error
```
- 다운캐스팅도 as를 사용하지만 다운 캐스팅은 실패할수도 있기때문에 as?나 as!를 사용한다.
- as!는 런타임에 타입 캐스팅을 하고 만약 타입 캐스팅에 실패하면 런타임 에러를 발생시킨다.
- as?는 런타임에 타입 캐스팅을 하고 만약 타입 캐스팅에 실패하면 nil을 반환한다.
```swift
let downcastedHun = hun as? HighSchoolStudent
print(downcastedHun) // nil

let forcelyDownCastedHun = hun as! HighSchoolStudent // runtime error
print(forcelyDownCastedHun)
```

# 3. \==연산자와 \=\==연산자의 차이
- == 연산자는 값을 비교하는데 사용하고 === 연산자는 참조 값을 비교하는데 사용한다.

# 4. Dispatch Queue의 Serial Queue에 대해서 설명해보세요
- 직렬 큐(serial queue)는 작업을 한 번에 하나씩 처리하는 작업 큐 이다.
- 직렬 큐는 스레드에 먼저 할당한 작업이 완전히 끝나야 큐에서 대기 중인 다음 작업을 스레드에 새로 할당한다.

# 5. let과 var의 차이는 무엇인가?
- let은 한번 할당된 값을 변경할 수 없는 상수를 선언하기 위한 명령어이고, var는 값을 변경할 수 있는 변수를 선언하기 위한 명령어이다.
- 사실 Objective-C의 관점에서 let은 주소에 대한 포인터를 바꿀 수 없다는 의미이다. 이 때문에 let으로 선언된 클래스 인스턴스 내부에 var로 선언된 변수의 값을 바꾸는 것은 가능하다.
```swift
let hun = Student(name: "hun")
hun.name = "hunihun965"

print(hun.name) // hunihun965
```

# 6. function과 method의 차이는?
- function은 재사용 가능한 코드 블록을 의미하고, method는 [[Class]], [[Struct]], [[Enum]]에 포함되는 function을 의미한다.

# 7. 커스텀 객체의 배열이 있을 때, 프로퍼티를 기준으로 배열을 어떻게 정렬할 수 있을까?
- sorted 메서드에 직접 소팅 클로저를 지정해줄 수 있다.
```swift
struct Node {
	let id: Int
}

let array = [
	Node(id: 5),
	Node(id: 4),
	Node(id: 3),
	Node(id: 2),
	Node(id: 1)
]

let sorted = array.sorted(by: { $0.id < $1.id })
print(sorted)
// [PS.Node(id: 1), PS.Node(id: 2), PS.Node(id: 3), PS.Node(id: 4), PS.Node(id: 5),]
```

# 8. mutating 키워드의 의미는?
- 스위프트에서 값 타입 프로퍼티들은 인스턴스 메서드에 의해 수정될 수 없다.
- mutating 키워드를 메서드 앞에 붙이면 [[Struct]], [[Enum]] 인스턴스에서 프로퍼티를 수정할 수 있게 된다.
- mutating 키워드가 붙은 메서드를 실행하면 스위프트는 새로운 구조체를 생성해 변경된 프로퍼티의 값을 할당하고 반환해 현재 구조체를 대체한다. [[Struct]]의 불변성을 지키기 위해 이런 방법을 사용한다.
- 변경되는 것이 아니라 새로 [[Struct]]를 만들어서 변경하려는 값으로 초기화해서 재할당하는 것

# 9. [[Protocol]]과 [[Class]]의 차이를 설명해보자.
- [[Class]]는 인스턴스 메서드의 실제 구현체를 가지고 있지만 [[Protocol]]은 메서드의 인터페이스만 가지고 있다.
- 프로토콜이 구현체를 가지게 하려면 프로토콜의 [[Extension]]을 만들어 구현체를 작성할 수 있다.

# 10. [[Enum]]에서 raw value와 associated value에 대해 설명해보라
- raw value는 원시값으로 [[Enum]]의 모든 case들이 동일한 타입을 가지고 하나의 값만 가질 수 있다.
- 반면에 associated value는 튜플을 통해 각 case들이 다른 타입을 가지게 할 수도 있고, names tuple로 이름을 붙일 수도 있으며, 여러개의 값을 가지게 하는 것도 가능하다.
```swift
enum Fruits {
	case apple(origin: String, cost: Double)
	case grape(origin: String, cost: Double, size: Double)
	case orange(color: String)
}

let apple: Fruits = .apple(origin: "Korea", cost: 1000)
let grape: Fruits = .grape(origin: "Korea", cost: 100, size: 10)
let orange: Fruits = .orange(color: "Orange")

// raw values
enum Numbers: Int {
	case one = 1
	case two, three, four
}

print(Numbers.one.rawValue) // 1
print(Numbers.two.rawValue) // 2
print(Numbers.three.rawValue) // 3

```

# 11.  inout은 언제 사용하면 좋을까?
- inout 파라미터를 사용하면 값 타입 변수가 저장된 주소의 값을 함수 안과 밖에서 동일하게 사용하게 된다.
- 따라서 함수가 입력과 동일한 출력을 제공하고, 함수 내에서 적용된 변경사항이 함수 외부에서도 동일하게 적용되어야할 때 사용할 수 있다.
- Swap을 직접 구현하고자 한다면 inout이 좋은 선택이 될 수 있다.
```swift
func swap<T>(a: inout T, b: inout T) {
	(a, b) = (b, a)
}

var a = 0, b = 1
swap(a: &a, b: &b)
```
- 함수 외부에서 선언한 값 타입의 변수를 함수 내부에서 작업하고 싶을때 사용하면 좋을듯하다.
# 12. 연산 프로퍼티와 클로저를 가지는 저장 프로퍼티의 차이를 설명해보라
- 클로저를 가지는 저장 프로퍼티는 프로퍼티의 생성시점에 클로저를 생성하고 사용한다.
- 또한 var 키워드로 생성되어 있다면 다른 클로저를 할당해주는 것도 가능하다.
- 연산 프로퍼티는 프로퍼티를 참조할 때마다 클로저를 생성하고 실행한다.
- 연산 프로퍼티는 프로퍼티를 참조할 때마다 클로저를 생성해서 실행하고 클로저를 가지는 저장 프로퍼티는 프로퍼티 생성시점에 생성되고 재생성되지 않는다.

# 13. as?와 as! 차이를 설명해보자.
- as?와 as! 모두 런타임에 다운캐스팅을 위해 사용되지만 as?는 캐스팅에 실패했을 때 nil을 반환하고 as!는 캐스팅에 실패했을때 런타임 에러를 발생시킨다.

# 14.  메서드 안에서 언제 self를 사용해야할까?
- 파라미터의 이름이 인스턴스의 프로퍼티 이름과 겹칠 경우에 인스턴스의 프로퍼티임을 명시하기 위해서 self를 사용할 수 있다.

# 15. [[Class]]와 [[Struct]]의 공통점과 차이점을 설명해보라.
## 공통점 
- Class와 Struct 모두 프로퍼티를 정의해 데이터를 저장하고 인스턴스를 만들어 객체의 형태로 사용할 수 있다.
- Class와 Struct 모두 프로토콜을 채택할 수 있다.
## 차이점
- Class는 참조 타입이지만 Struct는 값 타입이다.
- Class는 참조 타입이기 때문에 최적화를 사용하지 않지만 Struct는 값 타입의 복사를 최적화하기 위해서 Copy-On-Write를 사용한다. 실제로 변경이 일어나기 전까지는 구조체를 다른 변수에 할당하더라도 같은 주소의 구조체를 공유하다가 변경이 발생하면 새로운 주소에 인스턴스를 생성해 할당하는 것을 의미한다.
- Class는 힙 영역에 인스턴스를 저장하고 인스턴스의 주소값을 스택 영역에 저장한다. 반면에 Struct는 스택 영역에 인스턴스가 저장된다.
- Class는 인스턴스끼리의 상속이 가능하지만 Struct는 불가능하다. 대신 프로토콜을 통해 상속의 동작을 구현할 수는 있다.